(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{224:function(t,s,a){"use strict";a.r(s);var e=a(10),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器原理-回流和重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理-回流和重绘"}},[t._v("#")]),t._v(" 浏览器原理-回流和重绘")]),t._v(" "),a("h2",{attrs:{id:"回流-reflow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow"}},[t._v("#")]),t._v(" 回流 Reflow")]),t._v(" "),a("p",[t._v("当 "),a("code",[t._v("render tree")]),t._v("中的一部分(或全部)，因为元素的规模尺寸、布局、隐藏等改变\n而需要重新构建，这就是回流("),a("code",[t._v("reflow")]),t._v(")")]),t._v(" "),a("p",[t._v("将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口("),a("code",[t._v("viewport")]),t._v(")内的确切位置和大小，这个计算的阶段就是回流")]),t._v(" "),a("ul",[a("li",[t._v("每个页面至少回流一次，即页面首次加载")]),t._v(" "),a("li",[t._v("回流时，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树")]),t._v(" "),a("li",[t._v("回流完成后，浏览器会重新绘制受影响的部分，是重绘过程")])]),t._v(" "),a("h3",{attrs:{id:"何时回流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#何时回流"}},[t._v("#")]),t._v(" 何时回流")]),t._v(" "),a("ul",[a("li",[t._v("调整窗口大小（Resizing the window）")]),t._v(" "),a("li",[t._v("改变字体（Changing the font）")]),t._v(" "),a("li",[t._v("增加或者移除样式表（Adding or removing a stylesheet）")]),t._v(" "),a("li",[t._v("内容变化，比如用户在input框中输入文字（Content changes, such as a user typing text in an input box）")]),t._v(" "),a("li",[t._v("激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)（Activation of CSS pseudo classes such as :hover (in IE the activation of the pseudo class of a sibling)）")]),t._v(" "),a("li",[t._v("操作 class 属性（Manipulating the class attribute）")]),t._v(" "),a("li",[t._v("脚本操作 DOM（A script manipulating the DOM）")]),t._v(" "),a("li",[t._v("计算 offsetWidth 和 offsetHeight 属性（Calculating offsetWidth and offsetHeight）")]),t._v(" "),a("li",[t._v("设置 style 属性的值 （Setting a property of the style attribute）")])]),t._v(" "),a("h2",{attrs:{id:"重绘-repaints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaints"}},[t._v("#")]),t._v(" 重绘 Repaints")]),t._v(" "),a("p",[t._v("当"),a("code",[t._v("render tree")]),t._v("中的一些元素需要更新属性，而这些属性只是影响元素的外\n观、风格，而不影响布局(例如："),a("code",[t._v("background-color")]),t._v(")，则称为重绘("),a("code",[t._v("repaints")]),t._v(")")]),t._v(" "),a("p",[t._v("特点：回流必将引起重绘，重绘不一定引起回流 回流比重绘的代价更高")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://segmentfault.com/img/remote/1460000017329984?w=1150&h=537",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"浏览器优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器优化"}},[t._v("#")]),t._v(" 浏览器优化")]),t._v(" "),a("p",[t._v("现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。")]),t._v(" "),a("p",[t._v("主要包括以下属性或方法：")]),t._v(" "),a("ul",[a("li",[t._v("offsetTop、offsetLeft、offsetWidth、offsetHeight")]),t._v(" "),a("li",[t._v("scrollTop、scrollLeft、scrollWidth、scrollHeight")]),t._v(" "),a("li",[t._v("clientTop、clientLeft、clientWidth、clientHeight")]),t._v(" "),a("li",[t._v("width、height")]),t._v(" "),a("li",[t._v("getComputedStyle()")]),t._v(" "),a("li",[t._v("getBoundingClientRect()")])]),t._v(" "),a("p",[t._v("所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。")]),t._v(" "),a("h2",{attrs:{id:"减少重绘与回流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#减少重绘与回流"}},[t._v("#")]),t._v(" 减少重绘与回流")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用 transform 替代 top")])]),t._v(" "),a("li",[a("p",[t._v("使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局")])]),t._v(" "),a("li",[a("p",[t._v("避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。")])]),t._v(" "),a("li",[a("p",[t._v("尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。")])]),t._v(" "),a("li",[a("p",[t._v("避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。")])])]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("span")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("span")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("style")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token style"}},[a("span",{pre:!0,attrs:{class:"token language-css"}},[t._v("\n  "),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("span")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" red"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div > a > span")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" red"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("style")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n")])])]),a("ul",[a("li",[a("p",[t._v("对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 "),a("code",[t._v("span")]),t._v(" 标签，然后找到 "),a("code",[t._v("span")]),t._v(" 标签上的 "),a("code",[t._v("a")]),t._v(" 标签，最后再去找到 "),a("code",[t._v("div")]),t._v(" 标签，然后给符合这种条件的 "),a("code",[t._v("span")]),t._v(" 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 "),a("code",[t._v("CSS")]),t._v(" 选择器，然后对于 "),a("code",[t._v("HTML")]),t._v(" 来说也尽量少的添加无意义标签，保证层级扁平。")])]),t._v(" "),a("li",[a("p",[t._v("将动画效果应用到"),a("code",[t._v("position")]),t._v("属性为"),a("code",[t._v("absolute")]),t._v("或"),a("code",[t._v("fixed")]),t._v("的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 "),a("code",[t._v("requestAnimationFrame")]),t._v("，详见探讨 "),a("code",[t._v("requestAnimationFrame")]),t._v(".")])]),t._v(" "),a("li",[a("p",[t._v("避免使用CSS表达式，可能会引发回流。")])]),t._v(" "),a("li",[a("p",[t._v("将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如"),a("code",[t._v("will-change、video、iframe")]),t._v("等标签，浏览器会自动将该节点变为图层。")])]),t._v(" "),a("li",[a("p",[t._v("CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。")])]),t._v(" "),a("li",[a("p",[t._v("JavaScript 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。")])]),t._v(" "),a("li",[a("p",[t._v("避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。")])]),t._v(" "),a("li",[a("p",[t._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")])]),t._v(" "),a("li",[a("p",[t._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")])])]),t._v(" "),a("h2",{attrs:{id:"display-none-与-visibility-hidden"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#display-none-与-visibility-hidden"}},[t._v("#")]),t._v(" display:none 与 visibility:hidden")]),t._v(" "),a("p",[a("code",[t._v("display:none")]),t._v("与 "),a("code",[t._v("visibility:hidden")]),t._v(" 的异同\n两者都可以在页面上隐藏节点。不同之处在于，")]),t._v(" "),a("p",[a("code",[t._v("display:none")]),t._v(" 隐藏后的元素不占据任何空间。它的宽度、高度等各种属性值都将“丢失”\n"),a("code",[t._v("visibility:hidden")]),t._v(" 隐藏的元素空间依旧存在。它仍具有高度、宽度等属性值")]),t._v(" "),a("p",[t._v("从性能的角度而言，即是回流与重绘的方面，")]),t._v(" "),a("p",[a("code",[t._v("display:none")]),t._v(" 会触发 "),a("code",[t._v("reflow（回流）")]),t._v(" "),a("code",[t._v("visibility:hidden")]),t._v(" 只会触发 repaint（重绘），因为没有发现位置变化\n他们两者在优化中 "),a("code",[t._v("visibility:hidden")]),t._v(" 会显得更好，因为我们不会因为它而去改变了文档中已经定义好的显示层次结构了。")]),t._v(" "),a("p",[t._v("对子元素的影响：")]),t._v(" "),a("p",[a("code",[t._v("display:none")]),t._v(" 一旦父节点元素应用了 "),a("code",[t._v("display:none")]),t._v("，父节点及其子孙节点元素全部不可见，而且无论其子孙元素如何设置 "),a("code",[t._v("display")]),t._v(" 值都无法显示；")]),t._v(" "),a("p",[a("code",[t._v("visibility:hidden")]),t._v(" 一旦父节点元素应用了 "),a("code",[t._v("visibility:hidden")]),t._v("，则其子孙后代也都会全部不可见。不过存在隐藏“失效”的情况。当其子孙元素应用了 "),a("code",[t._v("visibility:visible")])]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=n.exports}}]);