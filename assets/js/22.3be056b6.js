(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{226:function(_,v,l){"use strict";l.r(v);var t=l(10),i=Object(t.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("h1",{attrs:{id:"浏览器原理-url-到页面过程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理-url-到页面过程"}},[_._v("#")]),_._v(" 浏览器原理-URL 到页面过程")]),_._v(" "),l("ol",[l("li",[_._v("从浏览器接收 url 到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）")]),_._v(" "),l("li",[_._v("开启网络线程到发出一个完整的 http 请求（这一部分涉及到 dns 查询，tcp/ip 请求，五层因特网协议栈等知识）")]),_._v(" "),l("li",[_._v("从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）")]),_._v(" "),l("li",[_._v("后台和前台的 http 交互（这一部分包括 http 头部、响应码、报文结构、cookie 等知识，可以提下静态资源的 cookie 优化，以及编码解码，如 - gzip 压缩等）")]),_._v(" "),l("li",[_._v("单独拎出来的缓存问题，http 的缓存（这部分包括 http 缓存头部，etag，catch-control 等）")]),_._v(" "),l("li",[_._v("浏览器接收到 http 数据包后的解析流程（解析 html-词法分析然后解析成 dom 树、解析 css 生成 css 规则树、合并成 render 树，然后 - layout、painting 渲染、复合图层的合成、GPU 绘制、外链资源的处理、loaded 和 domcontentloaded 等）")]),_._v(" "),l("li",[_._v("CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC 等概念）")]),_._v(" "),l("li",[_._v("JS 引擎解析过程（JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）")]),_._v(" "),l("li",[_._v("其它（可以拓展不同的知识模块，如跨域，web 安全，hybrid 模式等等内容）")])]),_._v(" "),l("h2",{attrs:{id:"从浏览器接收-url-到开启网络请求线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#从浏览器接收-url-到开启网络请求线程"}},[_._v("#")]),_._v(" 从浏览器接收 url 到开启网络请求线程")]),_._v(" "),l("ul",[l("li",[l("p",[_._v("多进程的浏览器")]),_._v(" "),l("ul",[l("li",[_._v("浏览器是多进程的，有一个主控进程，以及每一个 tab 页面都会新开一个进程（某些情况下多个 tab 会合并进程）")]),_._v(" "),l("li",[_._v("Browser 进程：浏览器的主进程（负责协调、主控），只有一个")]),_._v(" "),l("li",[_._v("第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建")]),_._v(" "),l("li",[_._v("GPU 进程：最多一个，用于 3D 绘制")]),_._v(" "),l("li",[_._v("浏览器渲染进程（内核）：默认每个 Tab 页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白 tab 会合并成一个进程）")])])]),_._v(" "),l("li",[l("p",[_._v("多线程的浏览器内核")]),_._v(" "),l("p",[_._v("每一个 tab 页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程")]),_._v(" "),l("ul",[l("li",[_._v("GUI 线程")]),_._v(" "),l("li",[_._v("JS 引擎线程")]),_._v(" "),l("li",[_._v("事件触发线程")]),_._v(" "),l("li",[_._v("定时器线程")]),_._v(" "),l("li",[_._v("网络请求线程")])])]),_._v(" "),l("li",[l("p",[_._v("解析 URL\n输入 URL 后，会进行解析（URL 的本质就是统一资源定位符）\nprotocol，协议头，譬如有 http，ftp 等")]),_._v(" "),l("ul",[l("li",[_._v("host，主机域名或 IP 地址")]),_._v(" "),l("li",[_._v("port，端口号")]),_._v(" "),l("li",[_._v("path，目录路径")]),_._v(" "),l("li",[_._v("query，即查询参数")]),_._v(" "),l("li",[_._v("fragment，即#后的 hash 值，一般用来定位到某个位置")])])])]),_._v(" "),l("h2",{attrs:{id:"开启网络线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#开启网络线程"}},[_._v("#")]),_._v(" 开启网络线程")]),_._v(" "),l("h3",{attrs:{id:"dns-查询得到-ip"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#dns-查询得到-ip"}},[_._v("#")]),_._v(" DNS 查询得到 IP")]),_._v(" "),l("p",[_._v("如果输入的是域名，需要进行 dns 解析成 IP，大致流程：")]),_._v(" "),l("ul",[l("li",[_._v("如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host")]),_._v(" "),l("li",[_._v("如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP")])]),_._v(" "),l("p",[_._v("需要知道 "),l("code",[_._v("dns")]),_._v(" 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 "),l("code",[_._v("dns-prefetch")]),_._v(" 优化")]),_._v(" "),l("h3",{attrs:{id:"tcp-ip-请求"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip-请求"}},[_._v("#")]),_._v(" tcp/ip 请求")]),_._v(" "),l("ul",[l("li",[l("p",[_._v("第一次握手：客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认")])]),_._v(" "),l("li",[l("p",[_._v("第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态")])]),_._v(" "),l("li",[l("p",[_._v("第三次握手：客户端收到服务器的 SYN ＋ ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手 随后客户端与服务器端之间可以开始传输数据了")])]),_._v(" "),l("li",[l("p",[_._v("中断连接端可以是客户端，也可以是服务器端。")])]),_._v(" "),l("li",[l("p",[_._v('第一次挥手：客户端发送一个 FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据')])]),_._v(" "),l("li",[l("p",[_._v("第二次挥手：服务器端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。")])]),_._v(" "),l("li",[l("p",[_._v("第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。")])]),_._v(" "),l("li",[l("p",[_._v("第四次挥手：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。")])])]),_._v(" "),l("blockquote",[l("p",[_._v("客户端：hello，你是 server 么？\n服务端：hello，我是 server，你是 client 么\n客户端：yes，我是 client\n主动方：我已经关闭了向你那边的主动通道了，只能被动接收了\n被动方：收到通道关闭的信息\n被动方：那我也告诉你，我这边向你的主动通道也关闭了\n主动方：最后收到数据，之后双方无法通信")])]),_._v(" "),l("p",[_._v("浏览器对同一域名下并发的 tcp 连接是有限制的（2-10 个不等）")]),_._v(" "),l("h3",{attrs:{id:"post-get-差别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#post-get-差别"}},[_._v("#")]),_._v(" post/get 差别")]),_._v(" "),l("ul",[l("li",[_._v("对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）")]),_._v(" "),l("li",[_._v("GET 在浏览器回退时是无害的，而 POST 会再次提交请求")]),_._v(" "),l("li",[_._v("GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以")]),_._v(" "),l("li",[_._v("GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置")]),_._v(" "),l("li",[_._v("GET 请求只能进行 url 编码，而 POST 支持多种编码方式")]),_._v(" "),l("li",[_._v("GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留")]),_._v(" "),l("li",[_._v("GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有")]),_._v(" "),l("li",[_._v("对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制")]),_._v(" "),l("li",[_._v("GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息")]),_._v(" "),l("li",[_._v("GET 参数通过 URL 传递，POST 放在 Request body 中")])]),_._v(" "),l("h3",{attrs:{id:"五层协议"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#五层协议"}},[_._v("#")]),_._v(" 五层协议")]),_._v(" "),l("ul",[l("li",[_._v("1.应用层 通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。（DNS、HTTP 协议）")]),_._v(" "),l("li",[_._v("2.运输层 就是负责向两台主机进程之间的通信提供通用的数据传输服务（传输控制协议 TCP、用户数据协议 UDP）")]),_._v(" "),l("li",[_._v("3.网络层 负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报")]),_._v(" "),l("li",[_._v("4.数据链路层 数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）")]),_._v(" "),l("li",[_._v("5.物理层 在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异")])]),_._v(" "),l("h3",{attrs:{id:"七层协议"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#七层协议"}},[_._v("#")]),_._v(" 七层协议")]),_._v(" "),l("ul",[l("li",[_._v("物理层：底层数据传输，如网线；网卡标准。")]),_._v(" "),l("li",[_._v("数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡 MAC 地址。")]),_._v(" "),l("li",[_._v("网络层：定义 IP 编址，定义路由功能；如不同设备的数据转发。")]),_._v(" "),l("li",[_._v("传输层：端到端传输数据的基本功能；如 TCP、UDP。")]),_._v(" "),l("li",[_._v("会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。")]),_._v(" "),l("li",[_._v("标识层：数据格式标识，基本压缩加密功能。")]),_._v(" "),l("li",[_._v("应用层：各种应用软件，包括 Web 应用。")])]),_._v(" "),l("h3",{attrs:{id:"tcp-与-udp"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#tcp-与-udp"}},[_._v("#")]),_._v(" tcp 与 udp")]),_._v(" "),l("p",[_._v("TCP 向上层提供面向连接的可靠服务 ，UDP 向上层提供无连接不可靠服务。")]),_._v(" "),l("ul",[l("li",[l("p",[_._v("udp")]),_._v(" "),l("ul",[l("li",[_._v("1.面向无连接")]),_._v(" "),l("li",[_._v("2.有单播，多播，广播的功能")]),_._v(" "),l("li",[_._v("3.UDP 是面向报文的")]),_._v(" "),l("li",[_._v("4.不可靠性")]),_._v(" "),l("li",[_._v("5.头部开销小，传输数据报文时是很高效的")]),_._v(" "),l("li",[_._v("6.适用于实时应用（IP 电话、视频会议、直播等）")]),_._v(" "),l("li",[_._v("7.首部开销小，仅 8 字节")])])]),_._v(" "),l("li",[l("p",[_._v("tcp")]),_._v(" "),l("ul",[l("li",[_._v("1.TCP 连接过程")]),_._v(" "),l("li",[_._v("2.可靠传输，使用流量控制和拥塞控制")]),_._v(" "),l("li",[_._v("3.只能是一对一通信")]),_._v(" "),l("li",[_._v("4.面向字节流")]),_._v(" "),l("li",[_._v("5.适用于要求可靠传输的应用，例如文件传输")]),_._v(" "),l("li",[_._v("6.首部最小 20 字节，最大 60 字节")])])])])])}),[],!1,null,null,null);v.default=i.exports}}]);