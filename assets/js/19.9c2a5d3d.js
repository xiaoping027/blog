(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{223:function(e,v,_){"use strict";_.r(v);var r=_(10),t=Object(r.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器原理-css-解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理-css-解析"}},[e._v("#")]),e._v(" 浏览器原理-CSS 解析")]),e._v(" "),_("p",[e._v("和 HTML 不同，CSS 是上下文无关的语法，可以使用各种解析器进行解析。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image023.png",alt:"img"}})]),e._v(" "),_("p",[_("code",[e._v("WebKit")]),e._v(" 使用 "),_("code",[e._v("Flex")]),e._v(" 和 "),_("code",[e._v("Bison")]),e._v(" 解析器生成器，通过 "),_("code",[e._v("CSS")]),e._v(" 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。"),_("code",[e._v("Firefox")]),e._v(" 使用的是人工编写的自上而下的解析器。这两种解析器都会将 "),_("code",[e._v("CSS")]),e._v(" 文件解析成 "),_("code",[e._v("StyleSheet")]),e._v(" 对象，且每个对象都包含 "),_("code",[e._v("CSS")]),e._v(" 规则。"),_("code",[e._v("CSS")]),e._v(" 规则对象则包含选择器和声明对象，以及其他与 "),_("code",[e._v("CSS")]),e._v(" 语法对应的对象。")]),e._v(" "),_("p",[e._v("一旦 "),_("code",[e._v("CSS")]),e._v(" 被浏览器下载，"),_("code",[e._v("CSS")]),e._v(" 解析器就会被打开来处理它遇到的任何"),_("code",[e._v("CSS")]),e._v("。这可以是单个文档内的"),_("code",[e._v("CSS")]),e._v("、"),_("code",[e._v("<style>")]),e._v("标记内的 CSS，也可以是 "),_("code",[e._v("DOM")]),e._v(" 元素的"),_("code",[e._v("style")]),e._v("属性内嵌的 "),_("code",[e._v("CSS")]),e._v("。所有"),_("code",[e._v("CSS")]),e._v("都根据语法规范进行解析和标记。解析完成后，就会生成有一个包含所有选择器、属性和属性各自值的数据结构")]),e._v(" "),_("h2",{attrs:{id:"样式表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#样式表"}},[e._v("#")]),e._v(" 样式表")]),e._v(" "),_("p",[e._v("样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。")]),e._v(" "),_("p",[e._v("CSS 不会阻塞 DOM 的解析。 强调的是解析。浏览器是解析 DOM 生成 DOM Tree，结合 CSS 生成的 CSS Tree，最终组成 render tree，再渲染页面。由此可见，在此过程中 CSS 完全无法影响 DOM Tree，因而无需阻塞 DOM 解析。")]),e._v(" "),_("p",[_("code",[e._v("<script>")]),e._v("与"),_("code",[e._v("<link>")]),e._v("同时在头部的话，"),_("code",[e._v("<script>")]),e._v("在上可能会更好了么？之所以是可能，是因为如果"),_("code",[e._v("<link>")]),e._v("的内容下载更快的话，是没影响的，但反过来的话，JS 就要等待了，然而这些等待的时间是完全不必要的.")]),e._v(" "),_("ul",[_("li",[e._v("CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。")]),e._v(" "),_("li",[e._v('JS 阻塞 DOM 解析，但浏览器会"偷看"DOM，预先下载相关资源。')]),e._v(" "),_("li",[e._v("浏览器遇到 "),_("code",[e._v("<script>")]),e._v("且没有 defer 或 async 属性的 标签时，会触发页面渲染，因而如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。")])]),e._v(" "),_("h2",{attrs:{id:"解析顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解析顺序"}},[e._v("#")]),e._v(" 解析顺序")]),e._v(" "),_("p",[e._v("版引擎解析 CSS 选择器时是"),_("code",[e._v("从右往左")]),e._v("解析")]),e._v(" "),_("p",[e._v("1.HTML 经过解析生成 DOM Tree（这个我们比较熟悉）；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。")]),e._v(" "),_("p",[e._v("2.在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。")]),e._v(" "),_("p",[e._v("3.因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。")]),e._v(" "),_("p",[e._v("如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。")]),e._v(" "),_("h2",{attrs:{id:"解析过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解析过程"}},[e._v("#")]),e._v(" 解析过程")]),e._v(" "),_("p",[e._v("CSS 样式表解析过程中讲解的很细致，这里我们只看 CSS 语法解释器，大致过程如下：")]),e._v(" "),_("p",[e._v("1.先创建 CSSStyleSheet 对象。将 CSSStyleSheet 对象的指针存储到 CSSParser 对象中。")]),e._v(" "),_("p",[e._v("2.CSSParser 识别出一个 simple-selector ，形如 “div” 或者 “.class”。创建一个 CSSParserSelector 对象。")]),e._v(" "),_("p",[e._v("3.CSSParser 识别出一个关系符和另一个 simple-selecotr ，那么修改之前创建的 simple-selecotr, 创建组合关系符。")]),e._v(" "),_("p",[e._v("4.循环第3步直至碰到逗号或者左大括号。")]),e._v(" "),_("p",[e._v("5.如果碰到逗号，那么取出 CSSParser 的 reuse vector，然后将堆栈尾部的 CSSParserSelector 对象弹出存入 Vecotr 中，最后跳转至第2步。如果碰到左大括号，那么跳转至第6步。")]),e._v(" "),_("p",[e._v("6.识别属性名称，将属性名称的 hash 值压入解释器堆栈。")]),e._v(" "),_("p",[e._v("7.识别属性值，创建 CSSParserValue 对象，并将 CSSParserValue 对象存入解释器堆栈。")]),e._v(" "),_("p",[e._v("8.将属性名称和属性值弹出栈，创建 CSSProperty 对象。并将 CSSProperty 对象存入 CSSParser 成员变量m_parsedProperties 中。")]),e._v(" "),_("p",[e._v("9.如果识别处属性名称，那么转至第6步。如果识别右大括号，那么转至第10步。")]),e._v(" "),_("p",[e._v("10.将 reuse vector 从堆栈中弹出，并创建 CSSStyleRule 对象。CSSStyleRule 对象的选择符就是 reuse vector, 样式值就是 CSSParser 的成员变量 m_parsedProperties 。")]),e._v(" "),_("p",[e._v("11.把 CSSStyleRule 添加到 CSSStyleSheet 中。")]),e._v(" "),_("p",[e._v("12.清空 CSSParser 内部缓存结果。")]),e._v(" "),_("p",[e._v("13.如果没有内容了，那么结束。否则跳转值第2步。")]),e._v(" "),_("h2",{attrs:{id:"样式计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#样式计算"}},[e._v("#")]),e._v(" 样式计算")]),e._v(" "),_("p",[e._v("构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。")]),e._v(" "),_("p",[e._v("样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。")]),e._v(" "),_("p",[e._v("样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在“Firefox Profile”文件夹下）")]),e._v(" "),_("p",[e._v("样式计算存在以下难点:")]),e._v(" "),_("ul",[_("li",[e._v("样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。")]),e._v(" "),_("li",[e._v("如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。")]),e._v(" "),_("li",[e._v("应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次")])]),e._v(" "),_("p",[e._v("浏览器是通过以下方式处理的")]),e._v(" "),_("h3",{attrs:{id:"共享样式数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#共享样式数据"}},[e._v("#")]),e._v(" 共享样式数据")]),e._v(" "),_("p",[e._v("WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：")]),e._v(" "),_("p",[e._v("这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）")]),e._v(" "),_("ul",[_("li",[e._v("任何元素都没有 ID")]),e._v(" "),_("li",[e._v("标记名称应匹配")]),e._v(" "),_("li",[e._v("类属性应匹配")]),e._v(" "),_("li",[e._v("映射属性的集合必须是完全相同的")]),e._v(" "),_("li",[e._v("链接状态必须匹配")]),e._v(" "),_("li",[e._v("焦点状态必须匹配")]),e._v(" "),_("li",[e._v("任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配")]),e._v(" "),_("li",[e._v("元素中不能有任何 inline 样式属性")]),e._v(" "),_("li",[e._v("不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。")])]),e._v(" "),_("h3",{attrs:{id:"firefox-规则树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#firefox-规则树"}},[e._v("#")]),e._v(" Firefox 规则树")]),e._v(" "),_("p",[e._v("Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式")]),e._v(" "),_("p",[e._v("Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式")]),e._v(" "),_("p",[e._v("所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。")]),e._v(" "),_("h3",{attrs:{id:"对规则进行处理以简化匹配"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对规则进行处理以简化匹配"}},[e._v("#")]),e._v(" 对规则进行处理以简化匹配")]),e._v(" "),_("p",[e._v("样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。")]),e._v(" "),_("p",[e._v("这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了")]),e._v(" "),_("h3",{attrs:{id:"以正确的层叠顺序应用规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#以正确的层叠顺序应用规则"}},[e._v("#")]),e._v(" 以正确的层叠顺序应用规则")]),e._v(" "),_("p",[e._v("样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。")]),e._v(" "),_("p",[e._v("如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。")]),e._v(" "),_("ul",[_("li",[e._v("样式表层叠顺序")])]),e._v(" "),_("p",[e._v("1.浏览器声明\n2.用户普通声明\n3.作者普通声明\n4.作者重要声明\n5.用户重要声明")]),e._v(" "),_("p",[e._v("浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据特异性进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。")]),e._v(" "),_("p",[e._v("不同的 CSS 加载方式产生的 Style rule ，通过权重来确定谁覆盖谁")]),e._v(" "),_("h2",{attrs:{id:"css选择器效率"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css选择器效率"}},[e._v("#")]),e._v(" CSS选择器效率")]),e._v(" "),_("p",[e._v("CSS选择器效率从高到低的排序如下：")]),e._v(" "),_("ul",[_("li",[e._v("ID选择器 比如#header")]),e._v(" "),_("li",[e._v("类选择器 比如.promo")]),e._v(" "),_("li",[e._v("元素选择器 比如 div")]),e._v(" "),_("li",[e._v("兄弟选择器 比如 h2 + p")]),e._v(" "),_("li",[e._v("子选择器 比如 li > ul")]),e._v(" "),_("li",[e._v("后代选择器 比如 ul a 7. 通用选择器 比如 *")]),e._v(" "),_("li",[e._v("属性选择器 比如 type = “text”")]),e._v(" "),_("li",[e._v("伪类/伪元素选择器 比如 a:hover")])]),e._v(" "),_("p",[e._v("ID选择器和类选择器在速度上的差异很小很小")]),e._v(" "),_("blockquote",[_("p",[_("a",{attrs:{href:"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("a",{attrs:{href:"http://jartto.wang/2017/11/13/Exploring-the-principle-of-CSS-parsing/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://jartto.wang/2017/11/13/Exploring-the-principle-of-CSS-parsing/"),_("OutboundLink")],1),e._v(" "),_("a",{attrs:{href:"http://test.veryos.com/selector/slickspeed/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://test.veryos.com/selector/slickspeed/index.html"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=t.exports}}]);