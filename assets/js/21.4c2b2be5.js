(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{225:function(e,v,_){"use strict";_.r(v);var a=_(10),t=Object(a.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器原理-缓存机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理-缓存机制"}},[e._v("#")]),e._v(" 浏览器原理-缓存机制")]),e._v(" "),_("h2",{attrs:{id:"dns-缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns-缓存"}},[e._v("#")]),e._v(" DNS 缓存")]),e._v(" "),_("p",[e._v("全称 "),_("code",[e._v("Domain Name System")]),e._v(" ,即域名系统。 万维网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 "),_("code",[e._v("IP")]),e._v(" 数串。"),_("code",[e._v("DNS")]),e._v(" 协议运行在 UDP 协议之上，使用端口号 53。")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("DNS 解析")]),e._v(" "),_("p",[e._v("简单的说,通过域名,最终得到该域名对应的 IP 地址的过程叫做域名解析（或主机名解析）。\n"),_("code",[e._v("www.dnscache.com (域名) - DNS 解析 -> 11.222.33.444 (IP 地址)")])])]),e._v(" "),_("li",[_("p",[e._v("DNS 缓存\n有 DNS 的地方,就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对 DNS 结果做一定程度的缓存。")]),e._v(" "),_("p",[e._v("DNS 查询过程如下:")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("首先搜索浏览器自身的 DNS 缓存,如果存在，则域名解析到此完成。")])]),e._v(" "),_("li",[_("p",[e._v("如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的 hosts 文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。")])]),e._v(" "),_("li",[_("p",[e._v("如果本地 hosts 文件不存在映射关系，则查找本地 DNS 服务器(ISP 服务器,或者自己手动设置的 DNS 服务器),如果存在,域名到此解析完成。")])]),e._v(" "),_("li",[_("p",[e._v("如果本地 DNS 服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。")])])])])]),e._v(" "),_("h2",{attrs:{id:"cdn-缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cdn-缓存"}},[e._v("#")]),e._v(" CDN 缓存")]),e._v(" "),_("p",[e._v("全称 "),_("code",[e._v("Content Delivery Network")]),e._v(",即内容分发网络。")]),e._v(" "),_("p",[e._v("在浏览器本地缓存失效后,浏览器会向 "),_("code",[e._v("CDN")]),e._v(" 边缘节点发起请求。类似浏览器缓存,"),_("code",[e._v("CDN")]),e._v(" 边缘节点也存在着一套缓存机制。"),_("code",[e._v("CDN")]),e._v(" 边缘节点缓存策略因服务商不同而不同，但一般都会遵循 "),_("code",[e._v("http")]),e._v(" 标准协议，通过 "),_("code",[e._v("http")]),e._v(" 响应头中的 "),_("code",[e._v("Cache-control: max-age")]),e._v("的字段来设置 CDN 边缘节点数据缓存时间")]),e._v(" "),_("p",[e._v("当浏览器向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN 节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN 服务商一般会提供基于文件后缀、目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。")]),e._v(" "),_("ul",[_("li",[e._v("DNS 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。")]),e._v(" "),_("li",[e._v("大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源服务器的负载。\n戳此处详细了解 CDN 工作过程")])]),e._v(" "),_("h2",{attrs:{id:"浏览器缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[e._v("#")]),e._v(" 浏览器缓存")]),e._v(" "),_("p",[e._v("当浏览器请求一个网站的时候，会加载各种各样的资源，比如："),_("code",[e._v("HTML")]),e._v(" 文档、图片、"),_("code",[e._v("CSS")]),e._v(" 和 "),_("code",[e._v("JS")]),e._v(" 等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。")]),e._v(" "),_("p",[e._v("浏览器启用缓存至少有两点显而易见的好处：")]),e._v(" "),_("ul",[_("li",[e._v("减少页面加载时间")]),e._v(" "),_("li",[e._v("减少服务器负载")]),e._v(" "),_("li",[e._v("减少了冗余的数据传输")])]),e._v(" "),_("p",[e._v("浏览器是否使用缓存、缓存多久，是由"),_("code",[e._v("服务器")]),e._v("控制的。准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。")]),e._v(" "),_("h3",{attrs:{id:"存储位置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储位置"}},[e._v("#")]),e._v(" 存储位置")]),e._v(" "),_("ul",[_("li",[e._v("memory cache\n"),_("ul",[_("li",[e._v("MemoryCache 顾名思义，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit 早已支持 memoryCache。\n目前 Webkit 资源分成两类，一类是主资源，比如 HTML 页面，或者下载项，一类是派生资源，比如 HTML 页面中内嵌的图片或者脚本链接，分别对应代码中两个类：MainResourceLoader 和 SubresourceLoader。虽然 Webkit 支持 memoryCache，但是也只是针对派生资源，它对应的类为 CachedResource，用于保存原始数据（比如 CSS，JS 等），以及解码过的图片数据。")])])]),e._v(" "),_("li",[e._v("disk cache\n"),_("ul",[_("li",[e._v("DiskCache 顾名思义，就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为 CurlCacheManager。")])])])]),e._v(" "),_("table",[_("thead",[_("tr",[_("th",[e._v("-")]),e._v(" "),_("th",[e._v("memory cache")]),e._v(" "),_("th",[e._v("disk cache")])])]),e._v(" "),_("tbody",[_("tr",[_("td",[e._v("相同点")]),e._v(" "),_("td",[e._v("只能存储一些派生类资源文件")]),e._v(" "),_("td",[e._v("-")])]),e._v(" "),_("tr",[_("td",[e._v("不同点")]),e._v(" "),_("td",[e._v("退出进程时数据会被清除")]),e._v(" "),_("td",[e._v("退出进程时数据不会被清除")])]),e._v(" "),_("tr",[_("td",[e._v("存储资源")]),e._v(" "),_("td",[e._v("一般脚本、字体、图片会存在内存当中")]),e._v(" "),_("td",[e._v("一般非脚本会存在内存当中，如 css 等")])])])]),e._v(" "),_("p",[e._v("因为 CSS 文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中,但是 js 之类的脚本却随时可能会执行,如果脚本在磁盘当中,我们在执行脚本的时候需要从磁盘取到内存中来,这样 IO 开销就很大了,有可能导致浏览器失去响应。")]),e._v(" "),_("p",[e._v("三级缓存原理 (访问缓存优先级)")]),e._v(" "),_("ul",[_("li",[e._v("先在内存中查找,如果有,直接加载。")]),e._v(" "),_("li",[e._v("如果内存中不存在,则在硬盘中查找,如果有直接加载。")]),e._v(" "),_("li",[e._v("如果硬盘中也没有,那么就进行网络请求。")]),e._v(" "),_("li",[e._v("请求获取的资源缓存到硬盘和内存。")])]),e._v(" "),_("h3",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),_("p",[e._v("浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。")]),e._v(" "),_("p",[e._v("强缓存是利用 "),_("code",[e._v("Expires")]),e._v(" 或者 "),_("code",[e._v("Cache-Control")]),e._v(" 这两个 "),_("code",[e._v("http response header")]),e._v(" 实现的，它们都用来表示资源在客户端缓存的有效期。")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("Expires\n该字段是 "),_("code",[e._v("http1.0")]),e._v(" 时的规范，它的值为一个绝对时间的 GMT 格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。")]),e._v(" "),_("ul",[_("li",[e._v("浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Expires 的 header")]),e._v(" "),_("li",[e._v("浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header")]),e._v(" "),_("li",[e._v("浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行")]),e._v(" "),_("li",[e._v("如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新；")])])]),e._v(" "),_("li",[_("p",[e._v("Cache-Control\nCache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：")]),e._v(" "),_("ul",[_("li",[e._v("no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。")]),e._v(" "),_("li",[e._v("no-store：禁止使用缓存，每一次都要重新请求数据。")]),e._v(" "),_("li",[e._v("public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。")]),e._v(" "),_("li",[e._v("private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其- 缓存。")]),e._v(" "),_("li",[e._v("Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 - Cache-Control 优先级高。")])]),e._v(" "),_("p",[e._v("缓存过程：")]),e._v(" "),_("ul",[_("li",[e._v("浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Cache-Control 的 header，")]),e._v(" "),_("li",[e._v("浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来")]),e._v(" "),_("li",[e._v("浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行")]),e._v(" "),_("li",[e._v("如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新")])]),e._v(" "),_("p",[e._v("Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些")])])]),e._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),_("p",[e._v("浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 "),_("code",[e._v("http")]),e._v(" 状态为 "),_("code",[e._v("304")]),e._v(" 并且会显示一个 "),_("code",[e._v("Not Modified")]),e._v(" 的字符串")]),e._v(" "),_("p",[e._v("当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。")]),e._v(" "),_("p",[_("code",[e._v("Last-Modified，If-Modified-Since")]),e._v("的控制缓存的原理，如下：")]),e._v(" "),_("ul",[_("li",[e._v("浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间")]),e._v(" "),_("li",[e._v("浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值")]),e._v(" "),_("li",[e._v("服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header")]),e._v(" "),_("li",[e._v("浏览器收到 304 的响应后，就会从缓存中加载资源")]),e._v(" "),_("li",[e._v("如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。")])]),e._v(" "),_("p",[e._v("缺点:")]),e._v(" "),_("ul",[_("li",[e._v("短时间内资源发生了改变，Last-Modified 并不会发生变化")]),e._v(" "),_("li",[e._v("周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为,因此便有了 ETag。")])]),e._v(" "),_("p",[_("code",[e._v("ETag/If-None-Match")]),e._v("没有调整服务器时间和篡改客户端缓存的情况下，这两个 "),_("code",[e._v("header")]),e._v(" 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 "),_("code",[e._v("header")]),e._v(" 来管理协商缓存，这对 "),_("code",[e._v("header")]),e._v(" 就是"),_("code",[e._v("ETag、If-None-Match")])]),e._v(" "),_("ul",[_("li",[e._v("浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题")]),e._v(" "),_("li",[e._v("浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值")]),e._v(" "),_("li",[e._v("服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化")]),e._v(" "),_("li",[e._v("浏览器收到 304 的响应后，就会从缓存中加载资源")])]),e._v(" "),_("p",[e._v("Etag 和 Last-Modified 非常相似，都是用来判断一个参数，从而决定是否启用缓存。但是 ETag 相对于 Last-Modified 也有其优势，可以更加准确的判断文件内容是否被修改，从而在实际操作中实用程度也更高")]),e._v(" "),_("p",[e._v("Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e55dda0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",target:"_blank",rel:"noopener noreferrer"}},[e._v("img"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("当浏览器再次访问一个已经访问过的资源时，它会这样做：")]),e._v(" "),_("ul",[_("li",[e._v("1.看看是否命中强缓存，如果命中，就直接使用缓存了。")]),e._v(" "),_("li",[e._v("2.如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。")]),e._v(" "),_("li",[e._v("3.如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。")]),e._v(" "),_("li",[e._v("4.否则，返回最新的资源。")])])])}),[],!1,null,null,null);v.default=t.exports}}]);