(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{252:function(t,e,n){"use strict";n.r(e);var a=n(10),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"react-fiber"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[t._v("#")]),t._v(" React-Fiber")]),t._v(" "),n("p",[t._v("React 框架内部的运作可以分为 3 层：")]),t._v(" "),n("ul",[n("li",[t._v("Virtual DOM 层，描述页面长什么样。")]),t._v(" "),n("li",[t._v("Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。")]),t._v(" "),n("li",[t._v("Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。")])]),t._v(" "),n("p",[t._v("在 "),n("code",[t._v("v16")]),t._v(" 之前，"),n("code",[t._v("reconciliation")]),t._v(" 简单说就是一个自顶向下递归算法，产出需要对当前 DOM 进行更新或替换的操作列表，一旦开始，会持续占用主线程，中断操作却不容易实现。当 "),n("code",[t._v("JS")]),t._v(" 长时间执行（如大量计算等），会阻塞样式计算、绘制等工作，出现页面脱帧现象。所以，"),n("code",[t._v("v16")]),t._v(" 进行了一次重写，迎来了代号为 Fiber 的异步渲染架构。")]),t._v(" "),n("p",[n("code",[t._v("Fiber")]),t._v(" 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fiber "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  stateNode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 节点实例")]),t._v("\n  child"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子节点")]),t._v("\n  sibling"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 兄弟节点")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 父节点")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[n("code",[t._v("Fiber")]),t._v(" 核心是实现了一个基于"),n("code",[t._v("优先级")]),t._v("和 "),n("code",[t._v("requestIdleCallback")]),t._v(" 的循环任务调度算法")]),t._v(" "),n("ul",[n("li",[t._v("reconciliation 阶段可以把任务拆分成多个小任务")]),t._v(" "),n("li",[t._v("reconciliation 阶段可随时中止或恢复任务")]),t._v(" "),n("li",[t._v("可以根据优先级不同来选择优先执行任务")])]),t._v(" "),n("p",[t._v("优先级高的任务（如键盘输入）可以打断优先级低的任务（如 Diff）的执行，从而更快的生效。")]),t._v(" "),n("p",[t._v("任务的优先级有六种:")]),t._v(" "),n("ul",[n("li",[t._v("NoWork: 0, // No work is pending.")]),t._v(" "),n("li",[t._v("SynchronousPriority: 1, // 文本输入框")]),t._v(" "),n("li",[t._v("TaskPriority: 2, // 当前调度正执行的任务")]),t._v(" "),n("li",[t._v("AnimationPriority: 3, // 动画过渡")]),t._v(" "),n("li",[t._v("HighPriority: 4, // 用户交互反馈")]),t._v(" "),n("li",[t._v("LowPriority: 5, // 数据的更新")]),t._v(" "),n("li",[t._v("OffscreenPriority: 6, // 预估未来需要显示的任务")])]),t._v(" "),n("p",[n("code",[t._v("Fiber Reconciler")]),t._v(" 在执行过程中，会分为 2 个阶段。")]),t._v(" "),n("ul",[n("li",[t._v("阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。")]),t._v(" "),n("li",[t._v("阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。")])]),t._v(" "),n("p",[t._v("阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率")]),t._v(" "),n("ul",[n("li",[t._v("在任务队列中选出高优先级的 fiber node 执行，调用 requestIdleCallback 获取所剩时间，若执行时间超过了 deathLine，或者突然插入更高优先级的任务，则执行中断，保存当前结果，修改 tag 标记一下，设置为 pending 状态，迅速收尾并再调用一个 requestIdleCallback，等主线程释放出来再继续")]),t._v(" "),n("li",[t._v("恢复任务执行时，检查 tag 是被中断的任务，会接着继续做任务或者重做")])]),t._v(" "),n("h2",{attrs:{id:"fiber-树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fiber-树"}},[t._v("#")]),t._v(" Fiber 树")]),t._v(" "),n("p",[n("code",[t._v("Fiber Reconciler")]),t._v(" 在阶段一进行 Diff 计算的时候，会生成一棵 "),n("code",[t._v("Fiber")]),t._v(" 树。这棵树是在 "),n("code",[t._v("Virtual DOM")]),t._v(" 树的基础上增加额外的信息来生成的，它本质来说是一个链表.")]),t._v(" "),n("p",[n("code",[t._v("Fiber")]),t._v(" 树在首次渲染的时候会一次过生成。在后续需要 "),n("code",[t._v("Diff")]),t._v(" 的时候，会根据已有树和最新 "),n("code",[t._v("Virtual DOM")]),t._v(" 的信息，生成一棵新的树。这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行。如果没有，则继续构建树的过程：")]),t._v(" "),n("p",[t._v("如果过程中有优先级更高的任务需要进行，则 "),n("code",[t._v("Fiber Reconciler")]),t._v(" 会丢弃正在生成的树，在空闲的时候再重新执行一遍。")]),t._v(" "),n("p",[t._v("在构造 "),n("code",[t._v("Fiber")]),t._v(" 树的过程中，"),n("code",[t._v("Fiber Reconciler")]),t._v(" 会将需要更新的节点信息保存在 "),n("code",[t._v("Effect List")]),t._v(" 当中，在阶段二执行的时候，会批量更新相应的节点")]),t._v(" "),n("h2",{attrs:{id:"生命周期影响"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生命周期影响"}},[t._v("#")]),t._v(" 生命周期影响")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// reconciliation阶段")]),t._v("\ncomponentWillMount"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ncomponentWillReceiveProps"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nshouldComponentUpdate"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ncomponentWillUpdate"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// commit阶段")]),t._v("\ncomponentDidMount"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ncomponentDidUpdate"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ncomponentWillUnmount"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);