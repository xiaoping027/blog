(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{222:function(t,v,_){"use strict";_.r(v);var e=_(10),s=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器原理-渲染过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理-渲染过程"}},[t._v("#")]),t._v(" 浏览器原理-渲染过程")]),t._v(" "),_("p",[t._v("以谷歌浏览器为例子：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png",alt:"渲染过程"}})]),t._v(" "),_("ul",[_("li",[t._v("浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree")]),t._v(" "),_("li",[t._v("与此同时，进行CSS解析，生成Style Rules")]),t._v(" "),_("li",[t._v("接着将DOM Tree与Style Rules合成为 Render Tree")]),t._v(" "),_("li",[t._v("接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标")]),t._v(" "),_("li",[t._v("随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来")])]),t._v(" "),_("p",[t._v("浏览器是一个边解析边渲染的过程.首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上.当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。")]),t._v(" "),_("h2",{attrs:{id:"script-标签"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#script-标签"}},[t._v("#")]),t._v(" script 标签")]),t._v(" "),_("p",[_("code",[t._v("script")]),t._v(" 元素用于嵌入或引用可执行脚本")]),t._v(" "),_("p",[t._v("浏览器遇到 "),_("code",[t._v("<script>")]),t._v(" 标签时，会触发页面渲染")]),t._v(" "),_("p",[t._v("没有 "),_("code",[t._v("defer")]),t._v(" 或 "),_("code",[t._v("async")]),t._v(" ，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 "),_("code",[t._v("script")]),t._v(" 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行\n当浏览器解析的时候遇到"),_("code",[t._v("script")]),t._v("标签就会暂时挂起 "),_("code",[t._v("挂起渲染（加载解析渲染同步")]),t._v("的线程。这个时候就要等待 "),_("code",[t._v("js")]),t._v(" 文件加载完毕，还要等待解析执行完毕。所以我们一般会把 "),_("code",[t._v("script")]),t._v(" 写在文档的最后的原因。")]),t._v(" "),_("ul",[_("li",[t._v("1.停止解析")]),t._v(" "),_("li",[t._v("2.对src 资源进行请求")]),t._v(" "),_("li",[t._v("3.等待")]),t._v(" "),_("li",[t._v("4.执行脚本或者请求失败")]),t._v(" "),_("li",[t._v("5.继续解析")])]),t._v(" "),_("p",[t._v("在1-5当中,有网络延迟，可能导致无法继续渲染。")]),t._v(" "),_("h3",{attrs:{id:"async"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[t._v("#")]),t._v(" async")]),t._v(" "),_("p",[t._v("指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用 (即没有src属性的脚本）。加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。")]),t._v(" "),_("ul",[_("li",[t._v("无法保证dom已经完成渲染，所以一般用来加载一些外部脚步例如谷歌分析，用户信息捕捉等")]),t._v(" "),_("li",[t._v("下载完成立即执行")]),t._v(" "),_("li",[t._v("不会阻止解析dom文档")]),t._v(" "),_("li",[t._v("执行顺序不定")])]),t._v(" "),_("h3",{attrs:{id:"defer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#defer"}},[t._v("#")]),t._v(" defer")]),t._v(" "),_("p",[t._v("设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行.")]),t._v(" "),_("p",[t._v("加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成")]),t._v(" "),_("ul",[_("li",[t._v("不阻止解析 dom 文档,并行下载js 文件")]),t._v(" "),_("li",[t._v("下载完 js 文件 仍然会解析 dom 文档")]),t._v(" "),_("li",[t._v("按照页面中出现的顺序，在其他同步脚本执行后，DOMContentLoaded 事件前 依次执行")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://camo.githubusercontent.com/3cfc9c7f3ff4185cd5c2d9d40c03e942b98c6dfd/68747470733a2f2f692e737461636b2e696d6775722e636f6d2f77664c38322e706e67",alt:"img"}})])])}),[],!1,null,null,null);v.default=s.exports}}]);